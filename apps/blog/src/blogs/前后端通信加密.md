---
title: 前后端通信加密
date: 2025-03-06 14:00:00
categories: #分类
  - 业务场景
---

前景：给某银行做小程序，要求安全合规，通信必须双向加密，且密钥需要定期更新，防止泄漏，把加密的过程记录一下。

<!-- more -->

前后端主流加解密方式是采用对称加密 + 非对称加密结合的方式，在保证数据传递速度的前提下，达到安全的目的。流程如下图
![加解密步骤](../images/sm.png)
目前只关注前端部分

### 主要逻辑

```js
// 导入依赖
import JsEncrypt from 'jsencrypt' // 用于 RSA 加密
import CryptoJS from 'crypto-js' // 用于 AES 加密
import RSA from 'jsrsasign' // 用于 生成 RSA 密钥对

// 后端提供的 RSA 公钥。模拟生成
export const rsaKey = generateRSAKeyPair()

// 使用 AES 加密数据
function encryptWithAES(aesKey, data) {
  const keyHex = CryptoJS.enc.Utf8.parse(aesKey)
  const iv = generateRandomIV() // 生成随机IV
  const encrypted = CryptoJS.AES.encrypt(data, keyHex, {
    iv,
    mode: CryptoJS.mode.CBC,
    padding: CryptoJS.pad.Pkcs7,
  })
  return {
    encryptedData: encrypted.toString(),
    iv: CryptoJS.enc.Base64.stringify(iv),
  }
}

// 使用 RSA 加密 AES 密钥
function encryptAESKeyWithRSA(publicKey, aesKey) {
  const jsEncrypt = new JsEncrypt()
  jsEncrypt.setPublicKey(publicKey)
  const encryptedAESKey = jsEncrypt.encrypt(aesKey)
  if (!encryptedAESKey) throw new Error('RSA 加密失败')
  return encryptedAESKey // 返回 Base64 编码的 RSA 加密结果
}

// AES解密
export function decrypt(data, key, iv) {
  const keyHex = CryptoJS.enc.Utf8.parse(key)
  const ivHex = CryptoJS.enc.Base64.parse(iv)
  const decrypted = CryptoJS.AES.decrypt(data, keyHex, {
    iv: ivHex,
    mode: CryptoJS.mode.CBC,
    padding: CryptoJS.pad.Pkcs7,
  })
  return decrypted.toString(CryptoJS.enc.Utf8)
}

// 主加密函数
export function encryptData(data) {
  // 生成 AES 密钥
  const aesKey = getAesKey()
  const encryptedDataObj = encryptWithAES(aesKey, JSON.stringify(data)) // AES加密请求数据
  const encryptedAesKey = encryptAESKeyWithRSA(rsaKey.publicKey, aesKey) // RSA加密AES密钥

  // 返回加密后的结果
  return {
    encryptedAesKey, // RSA 加密的 AES 密钥
    encryptedData: encryptedDataObj.encryptedData, // AES 加密的数据
    iv: encryptedDataObj.iv, // 矢量
  }
}

// 生成AES随机密钥
function getAesKey(n = 16) {
  const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789'
  let res = ''
  for (let i = 0; i < n; i++) {
    const id = Math.floor(Math.random() * chars.length)
    res += chars[id]
  }
  console.log('加密前的AES密钥', res)
  return res
}
// 生成随机IV
function generateRandomIV() {
  const iv = new Uint8Array(16)
  for (let i = 0; i < 16; i++) {
    iv[i] = Math.floor(Math.random() * 256)
  }
  return CryptoJS.lib.WordArray.create(iv)
}

// 生成RSA密钥对
function generateRSAKeyPair() {
  // 生成密钥对
  const keyPair = RSA.KEYUTIL.generateKeypair('RSA', 1024) // 1024 或 2048 位密钥长度
  const publicKey = RSA.KEYUTIL.getPEM(keyPair.pubKeyObj, 'PKCS8PUB')
  const privateKey = RSA.KEYUTIL.getPEM(keyPair.prvKeyObj, 'PKCS8PRV')

  console.log('公钥', publicKey)
  console.log('私钥', privateKey)

  // 返回 Base64 编码的公钥和私钥
  return {
    publicKey: publicKey.replace(/(\r\n|\n|\r)/gm, ''), // 去除换行符
    privateKey: privateKey.replace(/(\r\n|\n|\r)/gm, ''), // 去除换行符
  }
}

// RSA解密
export function decryptWithPrivateKey(encryptedData, privateKey) {
  const jsEncrypt = new JsEncrypt()
  jsEncrypt.setPrivateKey(privateKey)
  const decryptedAESKey = jsEncrypt.decrypt(encryptedData)
  if (!decryptedAESKey) throw new Error('RSA 解密失败')
  return decryptedAESKey
}

```

### 使用

```js
const text = "Hello World!";
const encryptText = encryptData(text);
console.log("加密前的数据", text);
console.log("加密后的数据", encryptText);


// RSA解密，获取AES密钥
const decryptAESText = decryptWithPrivateKey(
  encryptText.encryptedAesKey,
  rsaKey.privateKey
);
console.log("解密后的AES数据", decryptAESText);

// 使用解密后的AES密钥解密数据，获取到明文
const decryptText = decrypt(
  encryptText.encryptedData,
  decryptAESText,
  encryptText.iv
);
console.log("解密后的数据", decryptText);
```

### 总结
后端可以设置一个有效期，如果发现私钥超时，返回一个错误码，并重新生成新的公私钥，前端重新调接口获取新的公钥后，再重新进行加解密操作。